//
// Rewrite the grammar given in the Tiger language specification below to remove the ambiguity
// by enforcing operator precedences and left and right associativity for different operators.
// This part is to be done by hand.
// 2. Modifying the grammar obtained in step 1 to support LL(k) parsing,
// k must be minimized, so that the parser is LL(1).
// This could include removing left recursion and performing left factoring on the grammar
// obtained in step 1 above. You are not allowed to rewrite the grammar except using these two techniques.
// This part is to be done by hand.


//Make sure we use RIGHT RECURSION and not LEFT RECURSION
//Also perform left factoring

start:  (_NEWLINE | stmt)*

    stmt: (funcdef | expr )

    funccall: funcfirm

    funcfirm: identifier "(" [paramlist] ")"

    funcdef: funcfirm ":" suite

    paramlist: expr ("," expr)* [ "|" boolean_expr]

    boolean_expr: bool_gt | bool_lt

    bool_gt: expr_element ">" expr

    bool_lt: expr_element "<" expr


    suite: stmt  |  _NEWLINE? stmt+ "." _NEWLINE?

    number: DEC_NUMBER | HEX_NUMBER | FLOAT

    expr: expr_element | arith_expr | "(" arith_expr ")"

    arith_expr: arith_add | arith_sub | arith_mul


    arith_add: expr_element "+" expr

    arith_sub: expr_element "-" expr

    arith_mul: expr_element "*" expr

    expr_element: identifier | number | funccall

    identifier: NAME


    COMMENT: /#[^\n]*/
    _NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

    string: STRING

    STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
    DEC_NUMBER: /[0-9]\d*l?/i
    HEX_NUMBER: /0x[\da-f]*l?/i

    %import common.FLOAT -> FLOAT
    %import common.INT -> _INT
    %import common.CNAME -> NAME

    %ignore /[\t \f]+/  // WS
    %ignore /\\[\t \f]*\r?\n/   // LINE_CONT
    %ignore COMMENT
    %declare _INDENT _DEDENT

